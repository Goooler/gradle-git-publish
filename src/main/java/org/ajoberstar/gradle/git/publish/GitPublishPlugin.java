package org.ajoberstar.gradle.git.publish;

import org.ajoberstar.gradle.git.publish.tasks.GitPublishCommit;
import org.ajoberstar.gradle.git.publish.tasks.GitPublishPush;
import org.ajoberstar.gradle.git.publish.tasks.GitPublishReset;
import org.ajoberstar.grgit.Grgit;
import org.ajoberstar.grgit.gradle.GrgitService;
import org.ajoberstar.grgit.gradle.GrgitServiceExtension;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.provider.Provider;
import org.gradle.api.tasks.Copy;
import org.gradle.api.tasks.TaskProvider;

public class GitPublishPlugin implements Plugin<Project> {
  static final String RESET_TASK = "gitPublishReset";
  static final String COPY_TASK = "gitPublishCopy";
  static final String COMMIT_TASK = "gitPublishCommit";
  static final String PUSH_TASK = "gitPublishPush";

  @Override
  public void apply(Project project) {
    var extension = project.getExtensions().create("gitPublish", GitPublishExtension.class, project);
    configureExtensionDefaults(project, extension);

    var grgitService = project.getGradle().getSharedServices().registerIfAbsent("git-publish-grgit", GrgitService.class, spec -> {
      spec.parameters(parameters -> {
        parameters.getDirectory().set(extension.getRepoDir());
        parameters.getInitIfNotExists().set(true);
      });
      spec.getMaxParallelUsages().set(1);
    });

    var reset = createResetTask(project, extension, grgitService);
    var copy = createCopyTask(project, extension);
    var commit = createCommitTask(project, extension, grgitService);
    var push = createPushTask(project, extension, grgitService);

    push.configure(t -> t.dependsOn(commit));
    commit.configure(t -> t.dependsOn(copy));
    copy.configure(t -> t.dependsOn(reset));
  }

  private void configureExtensionDefaults(Project project, GitPublishExtension extension) {
    extension.getCommitMessage().set("Generated by gradle-git-publish.");

    // if using the grgit-service plugin, default to the repo's origin
    project.getPluginManager().withPlugin("org.ajoberstar.grgit.service", plugin -> {
      var grgitExt = project.getExtensions().getByType(GrgitServiceExtension.class);
      // TODO should this be based on tracking branch instead of assuming origin?
      extension.getRepoUri().set(grgitExt.getService().map(service -> getOriginUri(service.getGrgit())));
      extension.getReferenceRepoUri().set(grgitExt.getService().map(service -> service.getGrgit().getRepository().getRootDir().toURI().toString()));
    });

    extension.getRepoDir().set(project.getLayout().getBuildDirectory().dir("gitPublish"));
  }

  private TaskProvider<GitPublishReset> createResetTask(Project project, GitPublishExtension extension, Provider<GrgitService> grgitService) {
    return project.getTasks().register(RESET_TASK, GitPublishReset.class, task -> {
      task.setGroup("publishing");
      task.setDescription("Prepares a git repo for new content to be generated.");
      task.getGrgitService().set(grgitService);
      task.getRepoUri().set(extension.getRepoUri());
      task.getReferenceRepoUri().set(extension.getReferenceRepoUri());
      task.getBranch().set(extension.getBranch());
      task.setPreserve(extension.getPreserve());
    });
  }

  private TaskProvider<Copy> createCopyTask(Project project, GitPublishExtension extension) {
    return project.getTasks().register(COPY_TASK, Copy.class, task -> {
      task.setGroup("publishing");
      task.setDescription("Copy contents to be published to git.");
      task.with(extension.getContents());
      task.into(extension.getRepoDir());
    });
  }

  private TaskProvider<GitPublishCommit> createCommitTask(Project project, GitPublishExtension extension, Provider<GrgitService> grgitService) {
    return project.getTasks().register(COMMIT_TASK, GitPublishCommit.class, task -> {
      task.setGroup("publishing");
      task.setDescription("Commits changes to be published to git.");
      task.getGrgitService().set(grgitService);
      task.getMessage().set(extension.getCommitMessage());
      task.getSign().set(extension.getSign());
    });
  }

  private TaskProvider<GitPublishPush> createPushTask(Project project, GitPublishExtension extension, Provider<GrgitService> grgitService) {
    return project.getTasks().register(PUSH_TASK, GitPublishPush.class, task -> {
      task.setGroup("publishing");
      task.setDescription("Pushes changes to git.");
      task.getGrgitService().set(grgitService);
      task.getBranch().set(extension.getBranch());
    });
  }

  private String getOriginUri(Grgit grgit) {
    return grgit.getRemote().list().stream()
        .filter(remote -> remote.getName().equals("origin"))
        .map(remote -> remote.getUrl())
        .findAny()
        .orElse(null);
  }
}
